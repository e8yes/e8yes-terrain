// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: light_source.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_light_5fsource_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_light_5fsource_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_light_5fsource_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_light_5fsource_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_light_5fsource_2eproto;
namespace e8 {
class LightSource;
class LightSourceDefaultTypeInternal;
extern LightSourceDefaultTypeInternal _LightSource_default_instance_;
class PointLight;
class PointLightDefaultTypeInternal;
extern PointLightDefaultTypeInternal _PointLight_default_instance_;
class SpotLight;
class SpotLightDefaultTypeInternal;
extern SpotLightDefaultTypeInternal _SpotLight_default_instance_;
class SunLight;
class SunLightDefaultTypeInternal;
extern SunLightDefaultTypeInternal _SunLight_default_instance_;
}  // namespace e8
PROTOBUF_NAMESPACE_OPEN
template<> ::e8::LightSource* Arena::CreateMaybeMessage<::e8::LightSource>(Arena*);
template<> ::e8::PointLight* Arena::CreateMaybeMessage<::e8::PointLight>(Arena*);
template<> ::e8::SpotLight* Arena::CreateMaybeMessage<::e8::SpotLight>(Arena*);
template<> ::e8::SunLight* Arena::CreateMaybeMessage<::e8::SunLight>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace e8 {

// ===================================================================

class SunLight PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e8.SunLight) */ {
 public:
  inline SunLight() : SunLight(nullptr) {};
  virtual ~SunLight();

  SunLight(const SunLight& from);
  SunLight(SunLight&& from) noexcept
    : SunLight() {
    *this = ::std::move(from);
  }

  inline SunLight& operator=(const SunLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline SunLight& operator=(SunLight&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SunLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SunLight* internal_default_instance() {
    return reinterpret_cast<const SunLight*>(
               &_SunLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SunLight& a, SunLight& b) {
    a.Swap(&b);
  }
  inline void Swap(SunLight* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SunLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SunLight* New() const final {
    return CreateMaybeMessage<SunLight>(nullptr);
  }

  SunLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SunLight>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SunLight& from);
  void MergeFrom(const SunLight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SunLight* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e8.SunLight";
  }
  protected:
  explicit SunLight(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_light_5fsource_2eproto);
    return ::descriptor_table_light_5fsource_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kIntensityFieldNumber = 2,
  };
  // repeated float direction = 1;
  int direction_size() const;
  private:
  int _internal_direction_size() const;
  public:
  void clear_direction();
  private:
  float _internal_direction(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_direction() const;
  void _internal_add_direction(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_direction();
  public:
  float direction(int index) const;
  void set_direction(int index, float value);
  void add_direction(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      direction() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_direction();

  // repeated float intensity = 2;
  int intensity_size() const;
  private:
  int _internal_intensity_size() const;
  public:
  void clear_intensity();
  private:
  float _internal_intensity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intensity() const;
  void _internal_add_intensity(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intensity();
  public:
  float intensity(int index) const;
  void set_intensity(int index, float value);
  void add_intensity(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intensity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intensity();

  // @@protoc_insertion_point(class_scope:e8.SunLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > direction_;
  mutable std::atomic<int> _direction_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intensity_;
  mutable std::atomic<int> _intensity_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_light_5fsource_2eproto;
};
// -------------------------------------------------------------------

class PointLight PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e8.PointLight) */ {
 public:
  inline PointLight() : PointLight(nullptr) {};
  virtual ~PointLight();

  PointLight(const PointLight& from);
  PointLight(PointLight&& from) noexcept
    : PointLight() {
    *this = ::std::move(from);
  }

  inline PointLight& operator=(const PointLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointLight& operator=(PointLight&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PointLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointLight* internal_default_instance() {
    return reinterpret_cast<const PointLight*>(
               &_PointLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PointLight& a, PointLight& b) {
    a.Swap(&b);
  }
  inline void Swap(PointLight* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointLight* New() const final {
    return CreateMaybeMessage<PointLight>(nullptr);
  }

  PointLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointLight>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PointLight& from);
  void MergeFrom(const PointLight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointLight* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e8.PointLight";
  }
  protected:
  explicit PointLight(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_light_5fsource_2eproto);
    return ::descriptor_table_light_5fsource_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kIntensityFieldNumber = 2,
  };
  // repeated float position = 1;
  int position_size() const;
  private:
  int _internal_position_size() const;
  public:
  void clear_position();
  private:
  float _internal_position(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_position() const;
  void _internal_add_position(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_position();
  public:
  float position(int index) const;
  void set_position(int index, float value);
  void add_position(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      position() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_position();

  // repeated float intensity = 2;
  int intensity_size() const;
  private:
  int _internal_intensity_size() const;
  public:
  void clear_intensity();
  private:
  float _internal_intensity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intensity() const;
  void _internal_add_intensity(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intensity();
  public:
  float intensity(int index) const;
  void set_intensity(int index, float value);
  void add_intensity(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intensity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intensity();

  // @@protoc_insertion_point(class_scope:e8.PointLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > position_;
  mutable std::atomic<int> _position_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intensity_;
  mutable std::atomic<int> _intensity_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_light_5fsource_2eproto;
};
// -------------------------------------------------------------------

class SpotLight PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e8.SpotLight) */ {
 public:
  inline SpotLight() : SpotLight(nullptr) {};
  virtual ~SpotLight();

  SpotLight(const SpotLight& from);
  SpotLight(SpotLight&& from) noexcept
    : SpotLight() {
    *this = ::std::move(from);
  }

  inline SpotLight& operator=(const SpotLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotLight& operator=(SpotLight&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpotLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpotLight* internal_default_instance() {
    return reinterpret_cast<const SpotLight*>(
               &_SpotLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SpotLight& a, SpotLight& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotLight* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpotLight* New() const final {
    return CreateMaybeMessage<SpotLight>(nullptr);
  }

  SpotLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpotLight>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpotLight& from);
  void MergeFrom(const SpotLight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotLight* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e8.SpotLight";
  }
  protected:
  explicit SpotLight(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_light_5fsource_2eproto);
    return ::descriptor_table_light_5fsource_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kIntensityFieldNumber = 3,
    kInnerConeAngleFieldNumber = 4,
    kOuterConeAngleFieldNumber = 5,
  };
  // repeated float position = 1;
  int position_size() const;
  private:
  int _internal_position_size() const;
  public:
  void clear_position();
  private:
  float _internal_position(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_position() const;
  void _internal_add_position(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_position();
  public:
  float position(int index) const;
  void set_position(int index, float value);
  void add_position(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      position() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_position();

  // repeated float direction = 2;
  int direction_size() const;
  private:
  int _internal_direction_size() const;
  public:
  void clear_direction();
  private:
  float _internal_direction(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_direction() const;
  void _internal_add_direction(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_direction();
  public:
  float direction(int index) const;
  void set_direction(int index, float value);
  void add_direction(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      direction() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_direction();

  // repeated float intensity = 3;
  int intensity_size() const;
  private:
  int _internal_intensity_size() const;
  public:
  void clear_intensity();
  private:
  float _internal_intensity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intensity() const;
  void _internal_add_intensity(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intensity();
  public:
  float intensity(int index) const;
  void set_intensity(int index, float value);
  void add_intensity(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intensity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intensity();

  // float inner_cone_angle = 4;
  void clear_inner_cone_angle();
  float inner_cone_angle() const;
  void set_inner_cone_angle(float value);
  private:
  float _internal_inner_cone_angle() const;
  void _internal_set_inner_cone_angle(float value);
  public:

  // float outer_cone_angle = 5;
  void clear_outer_cone_angle();
  float outer_cone_angle() const;
  void set_outer_cone_angle(float value);
  private:
  float _internal_outer_cone_angle() const;
  void _internal_set_outer_cone_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:e8.SpotLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > position_;
  mutable std::atomic<int> _position_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > direction_;
  mutable std::atomic<int> _direction_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intensity_;
  mutable std::atomic<int> _intensity_cached_byte_size_;
  float inner_cone_angle_;
  float outer_cone_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_light_5fsource_2eproto;
};
// -------------------------------------------------------------------

class LightSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e8.LightSource) */ {
 public:
  inline LightSource() : LightSource(nullptr) {};
  virtual ~LightSource();

  LightSource(const LightSource& from);
  LightSource(LightSource&& from) noexcept
    : LightSource() {
    *this = ::std::move(from);
  }

  inline LightSource& operator=(const LightSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightSource& operator=(LightSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LightSource& default_instance();

  enum ModelCase {
    kSunLight = 1,
    kPointLight = 2,
    kSpotLight = 3,
    MODEL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LightSource* internal_default_instance() {
    return reinterpret_cast<const LightSource*>(
               &_LightSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LightSource& a, LightSource& b) {
    a.Swap(&b);
  }
  inline void Swap(LightSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LightSource* New() const final {
    return CreateMaybeMessage<LightSource>(nullptr);
  }

  LightSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LightSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LightSource& from);
  void MergeFrom(const LightSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e8.LightSource";
  }
  protected:
  explicit LightSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_light_5fsource_2eproto);
    return ::descriptor_table_light_5fsource_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSunLightFieldNumber = 1,
    kPointLightFieldNumber = 2,
    kSpotLightFieldNumber = 3,
  };
  // .e8.SunLight sun_light = 1;
  bool has_sun_light() const;
  private:
  bool _internal_has_sun_light() const;
  public:
  void clear_sun_light();
  const ::e8::SunLight& sun_light() const;
  ::e8::SunLight* release_sun_light();
  ::e8::SunLight* mutable_sun_light();
  void set_allocated_sun_light(::e8::SunLight* sun_light);
  private:
  const ::e8::SunLight& _internal_sun_light() const;
  ::e8::SunLight* _internal_mutable_sun_light();
  public:
  void unsafe_arena_set_allocated_sun_light(
      ::e8::SunLight* sun_light);
  ::e8::SunLight* unsafe_arena_release_sun_light();

  // .e8.PointLight point_light = 2;
  bool has_point_light() const;
  private:
  bool _internal_has_point_light() const;
  public:
  void clear_point_light();
  const ::e8::PointLight& point_light() const;
  ::e8::PointLight* release_point_light();
  ::e8::PointLight* mutable_point_light();
  void set_allocated_point_light(::e8::PointLight* point_light);
  private:
  const ::e8::PointLight& _internal_point_light() const;
  ::e8::PointLight* _internal_mutable_point_light();
  public:
  void unsafe_arena_set_allocated_point_light(
      ::e8::PointLight* point_light);
  ::e8::PointLight* unsafe_arena_release_point_light();

  // .e8.SpotLight spot_light = 3;
  bool has_spot_light() const;
  private:
  bool _internal_has_spot_light() const;
  public:
  void clear_spot_light();
  const ::e8::SpotLight& spot_light() const;
  ::e8::SpotLight* release_spot_light();
  ::e8::SpotLight* mutable_spot_light();
  void set_allocated_spot_light(::e8::SpotLight* spot_light);
  private:
  const ::e8::SpotLight& _internal_spot_light() const;
  ::e8::SpotLight* _internal_mutable_spot_light();
  public:
  void unsafe_arena_set_allocated_spot_light(
      ::e8::SpotLight* spot_light);
  ::e8::SpotLight* unsafe_arena_release_spot_light();

  void clear_model();
  ModelCase model_case() const;
  // @@protoc_insertion_point(class_scope:e8.LightSource)
 private:
  class _Internal;
  void set_has_sun_light();
  void set_has_point_light();
  void set_has_spot_light();

  inline bool has_model() const;
  inline void clear_has_model();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ModelUnion {
    ModelUnion() {}
    ::e8::SunLight* sun_light_;
    ::e8::PointLight* point_light_;
    ::e8::SpotLight* spot_light_;
  } model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_light_5fsource_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SunLight

// repeated float direction = 1;
inline int SunLight::_internal_direction_size() const {
  return direction_.size();
}
inline int SunLight::direction_size() const {
  return _internal_direction_size();
}
inline void SunLight::clear_direction() {
  direction_.Clear();
}
inline float SunLight::_internal_direction(int index) const {
  return direction_.Get(index);
}
inline float SunLight::direction(int index) const {
  // @@protoc_insertion_point(field_get:e8.SunLight.direction)
  return _internal_direction(index);
}
inline void SunLight::set_direction(int index, float value) {
  direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.SunLight.direction)
}
inline void SunLight::_internal_add_direction(float value) {
  direction_.Add(value);
}
inline void SunLight::add_direction(float value) {
  _internal_add_direction(value);
  // @@protoc_insertion_point(field_add:e8.SunLight.direction)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SunLight::_internal_direction() const {
  return direction_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SunLight::direction() const {
  // @@protoc_insertion_point(field_list:e8.SunLight.direction)
  return _internal_direction();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SunLight::_internal_mutable_direction() {
  return &direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SunLight::mutable_direction() {
  // @@protoc_insertion_point(field_mutable_list:e8.SunLight.direction)
  return _internal_mutable_direction();
}

// repeated float intensity = 2;
inline int SunLight::_internal_intensity_size() const {
  return intensity_.size();
}
inline int SunLight::intensity_size() const {
  return _internal_intensity_size();
}
inline void SunLight::clear_intensity() {
  intensity_.Clear();
}
inline float SunLight::_internal_intensity(int index) const {
  return intensity_.Get(index);
}
inline float SunLight::intensity(int index) const {
  // @@protoc_insertion_point(field_get:e8.SunLight.intensity)
  return _internal_intensity(index);
}
inline void SunLight::set_intensity(int index, float value) {
  intensity_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.SunLight.intensity)
}
inline void SunLight::_internal_add_intensity(float value) {
  intensity_.Add(value);
}
inline void SunLight::add_intensity(float value) {
  _internal_add_intensity(value);
  // @@protoc_insertion_point(field_add:e8.SunLight.intensity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SunLight::_internal_intensity() const {
  return intensity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SunLight::intensity() const {
  // @@protoc_insertion_point(field_list:e8.SunLight.intensity)
  return _internal_intensity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SunLight::_internal_mutable_intensity() {
  return &intensity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SunLight::mutable_intensity() {
  // @@protoc_insertion_point(field_mutable_list:e8.SunLight.intensity)
  return _internal_mutable_intensity();
}

// -------------------------------------------------------------------

// PointLight

// repeated float position = 1;
inline int PointLight::_internal_position_size() const {
  return position_.size();
}
inline int PointLight::position_size() const {
  return _internal_position_size();
}
inline void PointLight::clear_position() {
  position_.Clear();
}
inline float PointLight::_internal_position(int index) const {
  return position_.Get(index);
}
inline float PointLight::position(int index) const {
  // @@protoc_insertion_point(field_get:e8.PointLight.position)
  return _internal_position(index);
}
inline void PointLight::set_position(int index, float value) {
  position_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.PointLight.position)
}
inline void PointLight::_internal_add_position(float value) {
  position_.Add(value);
}
inline void PointLight::add_position(float value) {
  _internal_add_position(value);
  // @@protoc_insertion_point(field_add:e8.PointLight.position)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PointLight::_internal_position() const {
  return position_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PointLight::position() const {
  // @@protoc_insertion_point(field_list:e8.PointLight.position)
  return _internal_position();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PointLight::_internal_mutable_position() {
  return &position_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PointLight::mutable_position() {
  // @@protoc_insertion_point(field_mutable_list:e8.PointLight.position)
  return _internal_mutable_position();
}

// repeated float intensity = 2;
inline int PointLight::_internal_intensity_size() const {
  return intensity_.size();
}
inline int PointLight::intensity_size() const {
  return _internal_intensity_size();
}
inline void PointLight::clear_intensity() {
  intensity_.Clear();
}
inline float PointLight::_internal_intensity(int index) const {
  return intensity_.Get(index);
}
inline float PointLight::intensity(int index) const {
  // @@protoc_insertion_point(field_get:e8.PointLight.intensity)
  return _internal_intensity(index);
}
inline void PointLight::set_intensity(int index, float value) {
  intensity_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.PointLight.intensity)
}
inline void PointLight::_internal_add_intensity(float value) {
  intensity_.Add(value);
}
inline void PointLight::add_intensity(float value) {
  _internal_add_intensity(value);
  // @@protoc_insertion_point(field_add:e8.PointLight.intensity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PointLight::_internal_intensity() const {
  return intensity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PointLight::intensity() const {
  // @@protoc_insertion_point(field_list:e8.PointLight.intensity)
  return _internal_intensity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PointLight::_internal_mutable_intensity() {
  return &intensity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PointLight::mutable_intensity() {
  // @@protoc_insertion_point(field_mutable_list:e8.PointLight.intensity)
  return _internal_mutable_intensity();
}

// -------------------------------------------------------------------

// SpotLight

// repeated float position = 1;
inline int SpotLight::_internal_position_size() const {
  return position_.size();
}
inline int SpotLight::position_size() const {
  return _internal_position_size();
}
inline void SpotLight::clear_position() {
  position_.Clear();
}
inline float SpotLight::_internal_position(int index) const {
  return position_.Get(index);
}
inline float SpotLight::position(int index) const {
  // @@protoc_insertion_point(field_get:e8.SpotLight.position)
  return _internal_position(index);
}
inline void SpotLight::set_position(int index, float value) {
  position_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.SpotLight.position)
}
inline void SpotLight::_internal_add_position(float value) {
  position_.Add(value);
}
inline void SpotLight::add_position(float value) {
  _internal_add_position(value);
  // @@protoc_insertion_point(field_add:e8.SpotLight.position)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SpotLight::_internal_position() const {
  return position_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SpotLight::position() const {
  // @@protoc_insertion_point(field_list:e8.SpotLight.position)
  return _internal_position();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SpotLight::_internal_mutable_position() {
  return &position_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SpotLight::mutable_position() {
  // @@protoc_insertion_point(field_mutable_list:e8.SpotLight.position)
  return _internal_mutable_position();
}

// repeated float direction = 2;
inline int SpotLight::_internal_direction_size() const {
  return direction_.size();
}
inline int SpotLight::direction_size() const {
  return _internal_direction_size();
}
inline void SpotLight::clear_direction() {
  direction_.Clear();
}
inline float SpotLight::_internal_direction(int index) const {
  return direction_.Get(index);
}
inline float SpotLight::direction(int index) const {
  // @@protoc_insertion_point(field_get:e8.SpotLight.direction)
  return _internal_direction(index);
}
inline void SpotLight::set_direction(int index, float value) {
  direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.SpotLight.direction)
}
inline void SpotLight::_internal_add_direction(float value) {
  direction_.Add(value);
}
inline void SpotLight::add_direction(float value) {
  _internal_add_direction(value);
  // @@protoc_insertion_point(field_add:e8.SpotLight.direction)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SpotLight::_internal_direction() const {
  return direction_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SpotLight::direction() const {
  // @@protoc_insertion_point(field_list:e8.SpotLight.direction)
  return _internal_direction();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SpotLight::_internal_mutable_direction() {
  return &direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SpotLight::mutable_direction() {
  // @@protoc_insertion_point(field_mutable_list:e8.SpotLight.direction)
  return _internal_mutable_direction();
}

// repeated float intensity = 3;
inline int SpotLight::_internal_intensity_size() const {
  return intensity_.size();
}
inline int SpotLight::intensity_size() const {
  return _internal_intensity_size();
}
inline void SpotLight::clear_intensity() {
  intensity_.Clear();
}
inline float SpotLight::_internal_intensity(int index) const {
  return intensity_.Get(index);
}
inline float SpotLight::intensity(int index) const {
  // @@protoc_insertion_point(field_get:e8.SpotLight.intensity)
  return _internal_intensity(index);
}
inline void SpotLight::set_intensity(int index, float value) {
  intensity_.Set(index, value);
  // @@protoc_insertion_point(field_set:e8.SpotLight.intensity)
}
inline void SpotLight::_internal_add_intensity(float value) {
  intensity_.Add(value);
}
inline void SpotLight::add_intensity(float value) {
  _internal_add_intensity(value);
  // @@protoc_insertion_point(field_add:e8.SpotLight.intensity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SpotLight::_internal_intensity() const {
  return intensity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SpotLight::intensity() const {
  // @@protoc_insertion_point(field_list:e8.SpotLight.intensity)
  return _internal_intensity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SpotLight::_internal_mutable_intensity() {
  return &intensity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SpotLight::mutable_intensity() {
  // @@protoc_insertion_point(field_mutable_list:e8.SpotLight.intensity)
  return _internal_mutable_intensity();
}

// float inner_cone_angle = 4;
inline void SpotLight::clear_inner_cone_angle() {
  inner_cone_angle_ = 0;
}
inline float SpotLight::_internal_inner_cone_angle() const {
  return inner_cone_angle_;
}
inline float SpotLight::inner_cone_angle() const {
  // @@protoc_insertion_point(field_get:e8.SpotLight.inner_cone_angle)
  return _internal_inner_cone_angle();
}
inline void SpotLight::_internal_set_inner_cone_angle(float value) {
  
  inner_cone_angle_ = value;
}
inline void SpotLight::set_inner_cone_angle(float value) {
  _internal_set_inner_cone_angle(value);
  // @@protoc_insertion_point(field_set:e8.SpotLight.inner_cone_angle)
}

// float outer_cone_angle = 5;
inline void SpotLight::clear_outer_cone_angle() {
  outer_cone_angle_ = 0;
}
inline float SpotLight::_internal_outer_cone_angle() const {
  return outer_cone_angle_;
}
inline float SpotLight::outer_cone_angle() const {
  // @@protoc_insertion_point(field_get:e8.SpotLight.outer_cone_angle)
  return _internal_outer_cone_angle();
}
inline void SpotLight::_internal_set_outer_cone_angle(float value) {
  
  outer_cone_angle_ = value;
}
inline void SpotLight::set_outer_cone_angle(float value) {
  _internal_set_outer_cone_angle(value);
  // @@protoc_insertion_point(field_set:e8.SpotLight.outer_cone_angle)
}

// -------------------------------------------------------------------

// LightSource

// .e8.SunLight sun_light = 1;
inline bool LightSource::_internal_has_sun_light() const {
  return model_case() == kSunLight;
}
inline bool LightSource::has_sun_light() const {
  return _internal_has_sun_light();
}
inline void LightSource::set_has_sun_light() {
  _oneof_case_[0] = kSunLight;
}
inline void LightSource::clear_sun_light() {
  if (_internal_has_sun_light()) {
    if (GetArena() == nullptr) {
      delete model_.sun_light_;
    }
    clear_has_model();
  }
}
inline ::e8::SunLight* LightSource::release_sun_light() {
  // @@protoc_insertion_point(field_release:e8.LightSource.sun_light)
  if (_internal_has_sun_light()) {
    clear_has_model();
      ::e8::SunLight* temp = model_.sun_light_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.sun_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::e8::SunLight& LightSource::_internal_sun_light() const {
  return _internal_has_sun_light()
      ? *model_.sun_light_
      : *reinterpret_cast< ::e8::SunLight*>(&::e8::_SunLight_default_instance_);
}
inline const ::e8::SunLight& LightSource::sun_light() const {
  // @@protoc_insertion_point(field_get:e8.LightSource.sun_light)
  return _internal_sun_light();
}
inline ::e8::SunLight* LightSource::unsafe_arena_release_sun_light() {
  // @@protoc_insertion_point(field_unsafe_arena_release:e8.LightSource.sun_light)
  if (_internal_has_sun_light()) {
    clear_has_model();
    ::e8::SunLight* temp = model_.sun_light_;
    model_.sun_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LightSource::unsafe_arena_set_allocated_sun_light(::e8::SunLight* sun_light) {
  clear_model();
  if (sun_light) {
    set_has_sun_light();
    model_.sun_light_ = sun_light;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e8.LightSource.sun_light)
}
inline ::e8::SunLight* LightSource::_internal_mutable_sun_light() {
  if (!_internal_has_sun_light()) {
    clear_model();
    set_has_sun_light();
    model_.sun_light_ = CreateMaybeMessage< ::e8::SunLight >(GetArena());
  }
  return model_.sun_light_;
}
inline ::e8::SunLight* LightSource::mutable_sun_light() {
  // @@protoc_insertion_point(field_mutable:e8.LightSource.sun_light)
  return _internal_mutable_sun_light();
}

// .e8.PointLight point_light = 2;
inline bool LightSource::_internal_has_point_light() const {
  return model_case() == kPointLight;
}
inline bool LightSource::has_point_light() const {
  return _internal_has_point_light();
}
inline void LightSource::set_has_point_light() {
  _oneof_case_[0] = kPointLight;
}
inline void LightSource::clear_point_light() {
  if (_internal_has_point_light()) {
    if (GetArena() == nullptr) {
      delete model_.point_light_;
    }
    clear_has_model();
  }
}
inline ::e8::PointLight* LightSource::release_point_light() {
  // @@protoc_insertion_point(field_release:e8.LightSource.point_light)
  if (_internal_has_point_light()) {
    clear_has_model();
      ::e8::PointLight* temp = model_.point_light_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.point_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::e8::PointLight& LightSource::_internal_point_light() const {
  return _internal_has_point_light()
      ? *model_.point_light_
      : *reinterpret_cast< ::e8::PointLight*>(&::e8::_PointLight_default_instance_);
}
inline const ::e8::PointLight& LightSource::point_light() const {
  // @@protoc_insertion_point(field_get:e8.LightSource.point_light)
  return _internal_point_light();
}
inline ::e8::PointLight* LightSource::unsafe_arena_release_point_light() {
  // @@protoc_insertion_point(field_unsafe_arena_release:e8.LightSource.point_light)
  if (_internal_has_point_light()) {
    clear_has_model();
    ::e8::PointLight* temp = model_.point_light_;
    model_.point_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LightSource::unsafe_arena_set_allocated_point_light(::e8::PointLight* point_light) {
  clear_model();
  if (point_light) {
    set_has_point_light();
    model_.point_light_ = point_light;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e8.LightSource.point_light)
}
inline ::e8::PointLight* LightSource::_internal_mutable_point_light() {
  if (!_internal_has_point_light()) {
    clear_model();
    set_has_point_light();
    model_.point_light_ = CreateMaybeMessage< ::e8::PointLight >(GetArena());
  }
  return model_.point_light_;
}
inline ::e8::PointLight* LightSource::mutable_point_light() {
  // @@protoc_insertion_point(field_mutable:e8.LightSource.point_light)
  return _internal_mutable_point_light();
}

// .e8.SpotLight spot_light = 3;
inline bool LightSource::_internal_has_spot_light() const {
  return model_case() == kSpotLight;
}
inline bool LightSource::has_spot_light() const {
  return _internal_has_spot_light();
}
inline void LightSource::set_has_spot_light() {
  _oneof_case_[0] = kSpotLight;
}
inline void LightSource::clear_spot_light() {
  if (_internal_has_spot_light()) {
    if (GetArena() == nullptr) {
      delete model_.spot_light_;
    }
    clear_has_model();
  }
}
inline ::e8::SpotLight* LightSource::release_spot_light() {
  // @@protoc_insertion_point(field_release:e8.LightSource.spot_light)
  if (_internal_has_spot_light()) {
    clear_has_model();
      ::e8::SpotLight* temp = model_.spot_light_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.spot_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::e8::SpotLight& LightSource::_internal_spot_light() const {
  return _internal_has_spot_light()
      ? *model_.spot_light_
      : *reinterpret_cast< ::e8::SpotLight*>(&::e8::_SpotLight_default_instance_);
}
inline const ::e8::SpotLight& LightSource::spot_light() const {
  // @@protoc_insertion_point(field_get:e8.LightSource.spot_light)
  return _internal_spot_light();
}
inline ::e8::SpotLight* LightSource::unsafe_arena_release_spot_light() {
  // @@protoc_insertion_point(field_unsafe_arena_release:e8.LightSource.spot_light)
  if (_internal_has_spot_light()) {
    clear_has_model();
    ::e8::SpotLight* temp = model_.spot_light_;
    model_.spot_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LightSource::unsafe_arena_set_allocated_spot_light(::e8::SpotLight* spot_light) {
  clear_model();
  if (spot_light) {
    set_has_spot_light();
    model_.spot_light_ = spot_light;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e8.LightSource.spot_light)
}
inline ::e8::SpotLight* LightSource::_internal_mutable_spot_light() {
  if (!_internal_has_spot_light()) {
    clear_model();
    set_has_spot_light();
    model_.spot_light_ = CreateMaybeMessage< ::e8::SpotLight >(GetArena());
  }
  return model_.spot_light_;
}
inline ::e8::SpotLight* LightSource::mutable_spot_light() {
  // @@protoc_insertion_point(field_mutable:e8.LightSource.spot_light)
  return _internal_mutable_spot_light();
}

inline bool LightSource::has_model() const {
  return model_case() != MODEL_NOT_SET;
}
inline void LightSource::clear_has_model() {
  _oneof_case_[0] = MODEL_NOT_SET;
}
inline LightSource::ModelCase LightSource::model_case() const {
  return LightSource::ModelCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace e8

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_light_5fsource_2eproto
